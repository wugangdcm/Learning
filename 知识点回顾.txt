1、请你谈谈对volatile的理解
	是java虚拟机提供的轻量级的同步机制 有三个特性 保证可见性 不保证原子性 禁止指令重排
		
	JMM java memory model java内存模型 描述的是一组规则或规范
	JMM关于同步的规定
	1、线程解锁前 必须把共享变量的值刷新回主内存
	2、线程加锁前 必须读取主内存的最新值到自己的工作内存
	3、加锁解锁是用一把锁

	int a = 10;
	在主内存有个a=25的数据，
	三个线程来修改这个值，会把这个值拷贝到各自的工作内存(每个线程的私有数据区域)缓存起来
	t1把值改成30，写回主内存 a=30，t2,t3线程并不知道a已经修改，因此会造成数据的混乱
	
	双重加锁单例模式 没使用volatile的时候 可能出现问题
	private static SingletonDemo instance = null;
	private static volatile SingletonDemo instance = null;
	if(instance == null){
		synchronized(SingletonDemo.class){
			if(instance == null){
				instance = new SingletonDemo();
			}
		}
	}
	
	分析：对象的创建分布三步 2 3步可能重排序 就会拿到一个没初始化完成的对象
	1、分布内存空间
	2、初始化数据
	3、instance = 对象的指针指向这个引用

2、CAS是什么 比较并交换 如何保证数据的原子性的
	CAS的功能就是判断内存某个位置的值是否为预期值，如果是就更改为新值，否则不修改并返回false，这个过程是原子的
	Unsafe是CAS的核心类。java是无法访问底层系统的，需要通过本地(native)方法来访问,Unsafe相当于一个后门。基于
	该类可以直接操作特定的内存数据。Unsafe类在rt.jar sum.misc包中，其内部方法可以直接操作内存。Unsafe中类都是native修饰的
	CAS是一种系统原语，原语的执行必须是连续的不能被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致问题
	public final int getAndIncrement() {
	   return unsafe.getAndAddInt(this, valueOffset, 1);
	}
	//var1 当前对象引用 var2 当前对象内存偏移量 var4 需要更新操作的值
	getAndAddInt(Object var1,long var2,int var4){
		int var5;
		do{
			//先获取该对象内存中的当前值
			var5=this.getIntVolatile(var1,var2);
			//操作时在获取一次值并判断是否和上一步获取的值是否一致 如果一致 更新值 否则继续执行循环
		}while(!this.compareAndSwapInt(var1,var2,var5,var5+var4));
		return var5;
	}
	valueOffset表示该变量值在内存中的偏移地址，Unsafe就是根据内存你的偏移地址获取数据的
	value用volatile修饰，保证了内存的可见性
	
CAS的缺点：
	1、如果CAS比较值失败，会一致尝试修改，可能给CPU带来很大压力
	2、只能保证一个共享变量的原子性
	3、引出来的ABA问题
	
CAS-->Unsafe-->CAS底层思想-->ABA-->原子引用更新-->如何规避ABA问题

AtomicInteger的ABA问题，原子引用更新是什么，如何规避ABA问题
	多个线程在执行操作的时候，t1线程执行速度快，t2线程执行慢，假如主内出初始值为A，t1初次操作把A改成B，然后又把B改成A，
	此时主内存的值是一样的，t2线程执行更新的时候，发现当前值和预期的值是一样的，就会执行修改成功，中间过程有改动，t1线程是不管的。
	如果业务只关注最终结果，那么是没什么问题的，如果关注中间的处理步骤，那么ABA将是个问题。
	
	原子引用是指只关心对象的引用是否一致，数据是否变更不关注。比如User u1 =new User("zsan"); User u2 = u1;u2.setName("lis");
	由于u2的引用和u1是指向同一块内存地址，所有会更新数据成功，即使u2的数据已经改动。AtomicReference
	
	可以通过加版本号的方式解决，如同数据库的乐观锁一样。每次改动加一个版本号，每次更新前，当前线程拥有的版本号小于实际版本号时 不执行更新。AtomicStampedReference
	
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
List集合回顾：
					interface list
	abstract AbstractList			AbstractSequentialList
Vector				ArrayList			LinkedList
Vector是线程安全的，add用synchronized修饰 并发性能不好 构造函数中定义：capacityIncrement

	Vector底层依赖数组来实现，查询效率较高，增删效率较低
	Vector中的元素有序、可重复、允许null值，添加单个元素的话，只能添加到集合末尾
	Vector会自动进行扩容。扩容后的容量由增量来决定，（2倍 or 原容量+增量）
	大多数方法用关键字synchronized修饰，线程安全。

ArrayList是线程不安全的，没有使用锁机制保证 并发性能高

	ArrayList底层依赖数组来实现，查询效率较高，增删效率较低
	ArrayList中的元素有序、可重复、允许null值
	ArrayList会自动进行扩容1.5倍。初始化时尽量指定初始容量，可避免频繁扩容，影响程序执行效率
	线程不安全，适用于单线程环境。
	
LinkedList线程不安全

	LinkedList底层依赖双向循环链表实现，增删效率较高，查询效率较低
	LinkedList中的元素有序、可重复、允许null值
	线程不安全，适用于单线程环境。

1、Vector和ArrayList使用的是数据结构，所以方便查询：Object[] elementData
2、插入元素的执行逻辑
	 >> 1  二进制数往右移一位,高位补0 10的二进制是1010 左移一位后为0101 十进制为5
	 << 1 同上相反
	1、如果当前容器为空，默认容器大小为10
	2、如果容器不为空且元素size>10了 需要扩容，oldCapacity >> 1 及扩容当前容量的一半。
	3、Arrays.copyOf方法复制一份并指向当前数据的引用。
public boolean add(E e) {
	ensureCapacityInternal(size + 1); //初始化容器大小
	elementData[size++] = e;
	return true;
}
private void ensureCapacityInternal(int minCapacity) {
	ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}
private static int calculateCapacity(Object[] elementData, int minCapacity) {
	if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
		return Math.max(DEFAULT_CAPACITY, minCapacity);
	}
	return minCapacity;
}
private void ensureExplicitCapacity(int minCapacity) {
	modCount++;

	// overflow-conscious code
	if (minCapacity - elementData.length > 0)
		grow(minCapacity);
}
private void grow(int minCapacity) {
	// overflow-conscious code
	int oldCapacity = elementData.length;
	int newCapacity = oldCapacity + (oldCapacity >> 1);
	if (newCapacity - minCapacity < 0)
		newCapacity = minCapacity;
	if (newCapacity - MAX_ARRAY_SIZE > 0)
		newCapacity = hugeCapacity(minCapacity);
	// minCapacity is usually close to size, so this is a win:
	elementData = Arrays.copyOf(elementData, newCapacity);
}

ArrayList线程不安全的写法：多线程下才会出现 java.util.ConcurrentModificationException
List<String> arrayList = new ArrayList();
for (int i = 0; i < 300; i++) {
	new Thread(() -> {
		arrayList.add(UUID.randomUUID().toString().substring(0, 5));
		System.out.println(Thread.currentThread().getName() + " end list = " + arrayList);
	}).start();
}
解决方案：
1、new Vector() //synchronized 方法体 扩容增量+1
2、Collections.synchronizedList(new ArrayList<>());
3、new CopyOnWriteArrayList<>() 通过ReentrantLock 重入锁实现 基于复制的副本进行操作然后把新的副本数据指向原先的引用。扩容增量+1

Set集合回顾：
		interface set
HashSet		TreeSet		Tree
	Set集合是线程不安全的
	如果我们不需要保留存储顺序, 并且需要去掉重复元素, 使用Set.
	如果我们需要将元素排序, 那么使用TreeSet
	如果我们不需要排序, 使用HashSet, HashSet比TreeSet效率高.
	如果我们需要保留存储顺序, 又要过滤重复元素, 那么使用LinkedHashSet

要保证多线程环境下Set集合操作安全，javaAPI提供了两种方式
1、Collections.synchronizedSet(new HashSet<>());
2、new CopyOnWriteArraySet<>();

HashSet
	内部是一个HashMap map = new HashMap<>(); 当前值就是key，value是一个静态常量Object对象 map.put(e, PRESENT)==null; static final Object PRESENT = new Object();

TreeSet
	内部是一个TreeMap this(new TreeMap<E,Object>());当前值就是key，value是一个静态常量Object对象 map.put(e, PRESENT)==null;
	
LinkedHashSet	
	内部使用的是LinkedHashMap map = new LinkedHashMap<>(initialCapacity 16, loadFactor 0.75f); 
	
Map集合回顾：
				interface map
HashMap		LinkedHashMap	TreeMap 	Hashtable

Hashtable是线程安全的，通过synchronized修饰方法体保证
HashMap、LinkedHashMap、TreeMap是分线程安全的，javaAPI提供了两种方式
1、Collections.synchronizedMap(new HashMap<>());
2、new ConcurrentHashMap();

HashMap数据结构：
JDK1.7:数组+链表
JDK1.8:数组+链表+红黑树
默认输出容量：DEFAULT_INITIAL_CAPACITY = 1 << 4	16
为什么必须为2的N次方：1、方便&运算 2、为了扩容之后整体的移动
加载因子：DEFAULT_LOAD_FACTOR = 0.75f;时间与空间的一个折中值
列表转红黑树的阈值：TREEIFY_THRESHOLD = 8;
红黑树转列表的阈值：UNTREEIFY_THRESHOLD = 6;
转红黑树的条件：MIN_TREEIFY_CAPACITY = 64;

put解析：
hash(key):扰动函数 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); 散列尽可能的均匀分布
Node<K,V>[] resize() Initializes or doubles table size
创建一个容量为16的Node数据	
Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];	
与(&)运算比取模(%)运算快很多
1.7是头插法 1.8尾插法


















	
	
	