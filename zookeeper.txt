
-------------------------------------------------------------------------------------------------------
zookeeper相关知识:
	zookeeper是一个开源的分布式的，为分布式应用提供协调服务的apache项目
	从设计模式角度理解：是一个基于观察者模式设计的分布式服务管理框架。它负责存储和管理大家都关心的
	数据，然后接受观察者的注册，一旦这些数据的状态发生变化，zookeeper就将负责通知已经在zookeeper上注册的那些观察者做出相应的反应。
特点：
1、一个领导者Leader,多个跟随者follower组成的集群
2、集群中只有半数以上的几点存活，集群才能正常服务
3、全局数据一致：每个server保存一份相用的数据副本，client无论连接到那个server数据一致
4、更新请求顺序进行
5、数据更新原子性，一次数据更新要么成功要么失败
配置文件详解：
tickTime:2000ms
客户端与服务器或者服务器与服务器之间维持心跳，也就是每个tickTime时间就会发送一次心跳。通过心跳不仅能够用来监听机器的工作状态，
还可以通过心跳来控制Flower跟Leader的通信时间，默认情况下FL的会话时常是心跳间隔的两倍。
initLimit:10
集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）
syncLimit:5
集群中flower服务器（F）跟leader（L）服务器之间的请求和答应最多能容忍的心跳数。
dataDir:
该属性对应的目录是用来存放myid信息跟一些版本，日志，跟服务器唯一的ID信息等。
clientPort:2181
客户端连接的接口，客户端连接zookeeper服务器的端口，zookeeper会监听这个端口，接收客户端的请求访问！这个端口默认是2181。

监听原理：
	1、在main线程中创建zookeeper客户端,这时候会创建两个线程sendThread和eventThread,一个负责网络连接通信connet，一个负责监听listener
	2、通过connet线程将注册的监听事件发送给zookeeper
	3、在zookeeper的注册监听列表中将注册的监听事件添加到列表中
	4、zookeeper监听到数据变化，就会将信息发送给listener线程
	5、listener线程内部调用了process方法
ZAB协议 Zookeeper Atomic Broadcast原子广播
Server状态：选举状态
LOOKING，竞选状态。
FOLLOWING，随从状态，同步leader状态，参与投票。
OBSERVING，观察状态,同步leader状态，不参与投票。
LEADING，领导者状态。

选举机制：
	半数以上通过选出leader
	· 优先检查ZXID。ZXID比较大的服务器优先作为Leader。
	· 如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。
	
-------------------------------------------------------------------------------------------------------
分布式事务 2pc 3pc算法 paxos算法
2PC；
	第一阶段：PreCommit
		事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，然后向协调者反馈YES,NO。
	第二阶段：doCommit
		如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)。
注意：在2PC中，当等待超时，会进行回滚操作
	协调者超时机制：没收到参与者反馈时，执行回滚操作
	优缺点：
	 2PC的优点是很显然的，原理简单，实现方便。目前，绝大多数关系型数据库都是采用两阶段提交协议来完成分布式事务处理的
	1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的
	2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。
	3、数据不一致。出现分区，或者网络故障。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
	4、太过保守：2pc没有设计相应的容错机制，当任意一个参与者节点宕机，那么协调者超时没收到响应，就会导致整个事务回滚失败
	5、二阶段无法解决的问题：协调者（在第二阶段）发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。	
	  
3PC：
与两阶段提交不同的是，三阶段提交有两个改动点。
1、引入超时机制。（超时提交策略，当第三阶段参与者等待协调者超时后会提交事务，解决参与者同步阻塞问题，同时能在发生单点故障时，继续达成一致）
2、在第一阶段和第二阶段中插入一个准备阶段。（也是为了减少同步阻塞的发生范围）

	第一阶段：canCommit 
		3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
	第二阶段：PreCommit
		协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。
		假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。
		假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断
	第三阶段：doCommit
		执行提交
		中断事务 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务

Paxos算法就是解决这种分布式场景中的一致性问题。对于一般的开发人员来说，只需要知道paxos是一个分布式选举算法即可。多个节点之间存在两种通讯模型：共享内存（Shared memory）、消息传递（Messages passing），Paxos是基于消息传递的通讯模型的。
在Paxos算法中，有三种角色：
	Proposer
	Acceptor
	Learners