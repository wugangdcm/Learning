---------------------------------------------------------------------------------------------------
java是值传递还是引用传递：
值传递(pass by value)是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数
引用传递(pass by reference)是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数进行的修改，将影响到实际参数

值传递和引用传递之前的区别的重点
|		  |值传递		         |引用传递				|
|根本区别 |会创建副本 copy		 |不创建副本			|
|所以	  |函数中无法改变原始对象|函数中可以改变原始对象|

main{
	int i = 10;
	test(i);//实际参数
}
private void test(int j){//形式参数
}

结论：
java中只有值传递，只不过对于对象参数，值的内容是对象的引用


==和equals区别：

1、基础类型比较 char boolean byte float double long int short
使用==比较值是否相等。
2、引用类型比较
①重写了equals方法，比如String。

第一种情况：使用==比较的是String的引用是否指向了同一块内存

第二种情况：使用equals比较的是String的引用的对象内用是否相等。

②没有重写equals方法，比如User等自定义类

==和equals比较的都是引用是否指向了同一块内存。
---------------------------------------------------------------------------------------------------
并发编程三个比较重要的概念
1、原子性
对基本数据类型的变量读取和赋值是保证了原子性的，要么都成功，要么都失败，这些操作不可被中断
2、可见性
使用volatile关键字保证可见性的
3、有序性(涉及到重排序 只要求最终一致性)
	happens-before relationship
3.1 代码的执行顺序，编写在前面的发生在编写在后面的
3.2 unlock必须发生在lock之后
3.3 volatile修饰的变量，对一个变量的写操作先于对该变量的读操作
3.4 传递规则，操作A先于B，B先于C,那么A肯定先于C
3.5 线程启动规则，start方法肯定先于线程run
3.6 线程中断规则，interrupt这个动作必须发生在捕获该动作之前
3.7 对象销毁规则，初始化必须发生在finalize之前
3.8 线程终结规则，所有的操作都发生在线程死亡之前

volatile关键字
一旦一个共享变量被volatile修饰，具备两层语义
1、保证了不同线程间的可见性
强制对缓存的修改操作立刻写入主存
如果是写操作，他会导致其他cpu的缓存失效
2、禁止对其进行重排序，也就是保证了有序性
保证重排序的时候不会把后面的指令放到屏障的前面，也不会把前面的放到后面
3、并未保证原子性

volatile使用场景
1、状态量标记
2、屏障前后的一致性

---------------------------------------------------------------------------------------------------
1、不可变对象一定是线程安全的
2、可变对象不一定是不安全的
---------------------------------------------------------------------------------------------------