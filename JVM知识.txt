
jvm相关

堆区域分为：新生代 老年代 持久代（jdk1.8后去除该区域）
新生代分为 eden survivor(from to)三个区域 默认比8:1:1 垃圾回收15次后放入老年代 这个阈值可配置

垃圾回收常见算法：
1、引用计数
原理是此对象有一个引用，则增加一个计算，删除一个引用则叫上一个计算，垃圾回收时通收集计算为0的对象，
次算法最致命的是无法处理循环引用的问题

2、复制
此算法是把内存空间分为两个相等的区域，每次只使用其中一个区域，垃圾回收时遍历当前使用区域，把存活下来
的对象复制到另外一个区域，复制的时候还会进行相应的内存整理，不会出现碎片，缺点是需要两倍内存空间

3、mark-sweep 标记和清除算法
此算法执行分两阶段，第一阶段从引用到根结点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的清除。
此算法需要暂停整个应用，同时会产生内存碎片

4、mark-compact 标记-整理
此算法结合了标记清除和复制两个算法的优点，也是分两阶段。第一阶段从根结点开始标记所有被引用对象，第二阶段遍历
整个堆，清除未标记对象并且把存活对象压缩到堆的其中一块按顺序排放。次算法避免了标记清除的碎片问题，同时也避免了
复制算法的空间问题。

垃圾回收收集器
年轻代：
Serial 串行收集器
只用一个CPU/一条收集线程去完成GC工作，且在进行垃圾收集时必须暂停其他所有的工作线程。
Stop The World 简称STW 可以使用 -XX:+UserSerialGC打开 使用的复制算法

ParNew 并行收集器
是serial的多线程版本。

parallel scavenge
使用复制算法，也是并行多线程收集器，与其他收集器关注尽可能缩短垃圾收集时间不同，它更关注系统吞吐量：
系统吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）

老年代：
CMS coucurrent mark sweep 并发标记清除  可搭配年轻代的 serial 或者 parnew
是一款真正意义上的并发收集器。CMS是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现
整个GC过程分为四个步骤：
1、初始标记 CMS initial mark
2、并发标记 CMS concurrent mark 
3、重新标记 CMS remark
4、并发清除 CMS concurrent sweep,已死对象将会就地释放。
CMS默认启动回收线程数=cpu数目+3

Serial Old 可搭配年轻代的 serial 或者 parnew 或者 parallel scavenge
同年轻代不同的是采取的是标记-整理算法

Parallel Old 可搭配年轻代的 parallel scavenge

新老共有的收集器
G1 gabage first


----------------------------------------------------------------------------------------------------------
jps
jstat
SOC 相当于年轻代from内存空间 
S1C 相当于年轻代to内存空间
SOU 相当于年轻代from内存空间使用了多少
S1U 相当于年轻代to内存空间使用了多少
EC  Eden区空间大小
EU  Eden区空间使用了多少
OC  老年代内存空间
OU  老年代内存空间使用了多少
PC  持久代内存空间
PU  持久代内存空间使用了多少
YGC 次收集器收集的次数
YGCT 次收集器收集消耗的时间(秒)	 
FGC	满GC的次数
FGCT 满GC的消耗的时间(秒)
GCT 年轻代和年老代收集花费的时间

jinfo
jmap
jstack

----------------------------------------------------------------------------------------------------------
-Xms 初始堆大小
-Xmx 最大堆大小
-XX:NewSize=n 设置年轻代大小
-XX:NewRatio=n 设置年轻代和年老代的比值 如为3 表示年轻代和年老代比值为1:3
-XX:SurvicorRatio=n 年轻代中eden区与两个Survivor区的比值 如为3，表示Eden:Survicor=3:2 Eden:S0:S1=3:1:1 
-XX:MaxPermSize=n 设置持久代大小
-XX:+UserSerialGC 设置串行收集器
-XX:+UserParallelGC 设置并行收集器
-XX:+UserParallelOldGC 设置并行年老代收集器
-XX:+UserConcMarkSweepGC 设置并发收集器