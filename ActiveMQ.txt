
-------------------------------------------------------------------------------------------------------
MQ能干嘛：解耦 削峰 异步
ActiveMQ 后台端口号：61616  前端页面访问端口：8161
queue 队列先进先出。 多个消费者时 平均消费
	无论生产者先启动还是消费者先启动，都可以获取到消息体 
	负载均衡模式
	消息不会丢失
	处理性能不会有明显变化
	
topic 消费者订阅后，都可以收到消息
	先启动消费者，在启动生产者，那么消费者收不到生产者之前发布的消息
	没有订阅者时，产生废消息
	处理性能随着订阅者的增多而下降
Message组成：
	消息头
	消息体
	消息属性
通讯协议：
	tcp 61616
	ws
	mqtt
	amtt等自带的
	nio:需要自己配置
持久化机制：
kahaDB目录下4类文件和一个lock 默认的
	db-1.log  存储消息数据记录文件 默认大小32M
	db.data	该文件包含了持久化的BTree索引，索引了消息数据记录中的消息，他是消息的索引文件
	db.free	当前db.data文件里哪些页面是空闲的，文件具体内容是所有的空闲页的ID
	db.redo	用来进行消息恢复，如果kahadb消息存储在强制退出后启动，用于恢复BTree索引
	lock	文件锁 表示当前获得kahadb读写权限的broker
	<persistenceAdapter>
		<kahaDB directory="${activemq.data}/kahadb">
	</persistenceAdapter>
JDBC:
	<persistenceAdapter>
		<jdbcPersistenceAdapter dadaSource="#mysql-ds">
	</persistenceAdapter>
	dadaSource指定将要引用的持久化数据库bean名称，createTablesOnStartup是否在启动的时候
	创建数据表，默认是true,这样每次启动都会去创建数据表了，一般是第一次启动为Tue之后改为false
	
	启动后会创建三个表
	activemq_acks 记录topic订阅者
	activemq_lock
	activemq_msgs 记录具体消息记录，queue的消费完就删除了 totic的保留
	
JDBC加高速缓存:
	<persistenceFactory>
		<journalPersistenceAdapterFactory 
			journalLogFiles="4"
			journalLogFileSize="32768"
			userJournal="true"
			userQuickJournal="true"
			dadaSource="#mysql-ds"
			dataDirectory="activemq-data">
	</persistenceFactory>
	
	
LevelDB: V5.8版本以后
	暂时没获取认可，实际开发中还是以kahadb为默认

	http://activemq.apache.org/replicated-leveldb-store
	http://activemq.apache.org/redelivery-policy

	异步消息，通过回调确认
	延迟投递
	定时投递
	AMQ_scheduled_delay long 延迟投递的时间
	AMQ_scheduled_period long 重复投递的时间间隔
	AMQ_scheduled_repeat long 重复投递次数
	AMQ_scheduled_cron String cron表达式
具体哪些情况会引起消息重发 mq服务器->client
1、Client用了transactions且在session中调用了rolleback()
2、Client用了transactions且在commit()之前关闭或者没有commit
3、Client在CLIENT_ACKNOWLEDGE的传递模式下，在session中调用了recover()
请说说消息重发时间间隔和重发次数
initialRedeliveryDelay：1
maximumRedeliveries: 6
有毒消息poison ACK谈谈你的理解
一个消息被redelivedred超过默认的最大重发次数(6)时，消息端会给MQ发送个poison ack，
告诉broker不要再发了，这个时候broker会把这个消息放大DLQ(死信队列)
	
	
	
	
	
	
	
	
	
	
	
	
	
	